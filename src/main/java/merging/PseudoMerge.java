package merging;

import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class PseudoMerge {

    public static <T extends Comparable<T>> void merge(Comparator<T> comparator, Consumer<T> output, List<InputObject<T>> inputs) {
        Map<InputObject<T>, T> suppliersMap = inputs.stream().collect(Collectors.toMap(input -> input, InputObject::get));

        while (!suppliersMap.isEmpty()) {
            //задаем значение пары null
            Map.Entry<InputObject<T>, T> minPair = null;
            //итерируемся по энтриСету и оставляем самую минимальную пару
            for (Map.Entry<InputObject<T>, T> actualPair : suppliersMap.entrySet()) {
                //текущее значение пары по которой итерируемся
                T actualValue = actualPair.getValue();
                //если значение равно null(значит мы удаляем пару из мапы) и продолжаем цикл for со следующей пары
                if (actualValue == null) {
                    suppliersMap.remove(actualPair.getKey());
                    continue;
                }
                //если ничего нет, устанавливаем, либо сравниваем через компаратор
                if (minPair == null || comparator.compare(minPair.getValue(), actualValue) < 0) {
                    minPair = actualPair;
                }
            }
            if (minPair == null) {
                //FIXME подумой головой
                break;
            }
            output.accept(minPair.getValue());
            minPair.setValue(minPair.getKey().get());
        }
    }


/**
 метод проверяет и инициализирует файлы, возвращает лист инпут файлов с открытыми потоками и апи взаимодействия();
 метод проверяет и инициализирует файлы, возвращает лист инпут файлов с открытыми потоками и апи взаимодействия();
 окрытие потока для записи в выходной файл;
 проверка что файлы не пустые -> если файл не имеет содержимого - закрыть файл




 публичный статичный метод аргументы которого будет сетать парсер командной строки (Порядок сортировки,
 тип файлов,
 выходной файл,
 входные файлы)
 {

 Метод сортировки(лист листов == коллекция файлов с содержимым(строками из чисел или букв), енум типФайлов){

 комментарий для примера - 3 файла на вход из чисел {{1,3,5}, {2,4,6}, {4,7,10}}

 сохранение первых строк в текущее значение (стейт каждого инпут файла)
 если тип содержимого не соотвествует параметрам на вход сортировки - исключить файл.
 проход по текущим значениям актуальных файлов. ( 1-2-4)
 запись минимального в файл и изменение текущего значения файла с минимальным значением (запись 1 и изменение текущего значения первого файла на 3)
 проход по текущим значиниям файлов. ( 3-2-4)
 запись минимального в файл и изменение текущего значения файла с минимальным значением (запись 2 и изменение текущего значения второго файла на 4)
 проход по текущим значиниям файлов. ( 3-4-4)
 ...проходы до победного конца
 если файл не имеет следующего значения закрыть чтение из файла.
 если след значение файла некорректное или меньше предыдущего - обработать исключение (пропустить или закрыть файла).

 хз как развернуть алгоритм для обратной сортировки.
 Можно начинать с конца каждого файла и делать проход с уменьшением до нуля. Но это дублирование кода.
 Для прохода с конца надо дополнить апи файлов - сделать проверку на преыдущее значение и обернуть ридер чтобы отдавал последнюю строку. (сложна)
 хз как прикрутить компаротор который развернет сортировку и решит проблему дублирования кода, тк алгоритм сортировки не совсем традиционный.
 }
 }
 */


}






